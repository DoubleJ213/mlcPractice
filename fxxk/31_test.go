package fxxk

import (
	"fmt"
	"testing"
)

/*
31. 下一个排列
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。
例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。
更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，
那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。
如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。
必须 原地 修改，只允许使用额外常数空间。

示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]

提示：
1 <= nums.length <= 100
0 <= nums[i] <= 100
*/

/*
乍一看看不出规律，整个数找规律
123456
最低位往前移  6往前移动发现5比自己小，那后一个数 直接上6移到5前面 123465
123465
最低位5已经小于前面的数6，5移到6前面肯定不合适
最低位移到哪里待确定，找到前面的比当前最低位数小的那个 5发现移到4前面可以 那就是123546
123546
6移到前面4比自己小，123564 完事
123564 [1,2,3,5,6,4]
如果继续最后一位判断按照上面的逻辑，应该是给4 往前折腾。那按照上面算法，变成了124356，结果发现不对
应该是123645还是6再往前移。回顾一刚刚的动作，不是一直把最后一个数往前移动。4本来再前面的，如果继续这么弄的话，
那中间有一阵会变成123465


[1,2,3,4,5,6]  动2位，最后一位
[1,2,3,4,6,5]  发现动2位，反而变小了。那就准备动3位 5移到4前
[1,2,3,5,4,6]  刚刚动3位，继续最后一位开始。 6大于前面的4 564完事
[1,2,3,5,6,4]  动3位，先最后一位4，发现3位中4怎么移动都不行。那倒数第二位 变成654。坑又来了。还有个645比654小。大数换到前面来的时候，需要把后面的数又变成升序 6 4、5
[1,2,3,6,4,5]  动3位 6 5 4
[1,2,3,6,5,4]  继续 654 动3位，最后一位整过，最后2位整过，那就是倒数第三位。没必要继续折腾了，那下面应该是折腾动4个数
4 往前移动四位，然后找到比4 小的那个数 4 找到比当前小的，然后后面的升序排列356
[1,2,4,3,5,6]  动后4位.发现4 和3 换了个位置，356 和之前456逻辑是一样的。
[1,2,4,3,6,5]

上面是有些乱的，要写出来还得优化。
*/
func nextPermutation(nums []int) {
	/*
		https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order
		      翻译过来：
		      先找出最大的索引 k 满足 nums[k] < nums[k+1]，如果不存在，就翻转整个数组；
		      再找出另一个最大索引 l 满足 nums[l] > nums[k]；
		      交换 nums[l] 和 nums[k]；
		      最后翻转 nums[k+1:]。
		      举个例子：
		      比如 nums = [1,2,7,4,3,1]，下一个排列是什么？
		      我们找到第一个最大索引是 nums[1] = 2
		      再找到第二个最大索引是 nums[4] = 3
		      交换，nums = [1,3,7,4,2,1];
		      翻转，nums = [1,3,1,2,4,7]
		      完毕! 别人的思路，脑子不够用
	*/
}

func TestAl31(t *testing.T) {
	nextPermutation([]int{1, 2, 3})
	fmt.Println("31")
}
