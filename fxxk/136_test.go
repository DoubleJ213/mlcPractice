package fxxk

import (
	"fmt"
	"testing"
)

/*
136. 只出现一次的数字
给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
o(n) o(1)

示例 1 ：
输入：nums = [2,2,1]
输出：1
示例 2 ：
输入：nums = [4,1,2,1,2]
输出：4
示例 3 ：
输入：nums = [1]
输出：1

提示：
1 <= nums.length <= 3 * 10^4
-3 * 10^4 <= nums[i] <= 3 * 10^4
除了某个元素只出现一次以外，其余每个元素均出现两次。
*/

func singleNumber(nums []int) int {
	//位运算里面，异或 比较特殊。可以解决本题
	// 相同为0，不同为1
	// 异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）
	// 异或运算符 ^ 在Go语言中也可以用于按位取反操作   ^a 表示对a进行按位取反。
	res136 := 0
	for i := 0; i < len(nums); i++ {
		res136 ^= nums[i]
	}
	return res136
}

func TestAl136(t *testing.T) {
	fmt.Println(singleNumber([]int{0, 1, 2, 1, 2}))
	//0	 0000 同0 不同1
	//1  0000 ^ 0001 = 0001
	//2  0001 ^ 0010 = 0011
	//1  0011 ^ 0001 = 0010
	//2  0010 ^ 0010 = 0000
	fmt.Println(singleNumber([]int{4, 1, 2, 1, 2}))
	//4	 0100 同0 不同1
	//1  0100 ^ 0001 = 0101
	//2  0101 ^ 0010 = 0111
	//1  0111 ^ 0001 = 0110
	//2  0110 ^ 0010 = 0100
}
