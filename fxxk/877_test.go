package fxxk

/*
877. 石子游戏

Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，排成一行；每堆都有 正 整数颗石子，数目为 piles[i] 。
游戏以谁手中的石子最多来决出胜负。石子的 总数 是 奇数 ，所以没有平局。
Alice 和 Bob 轮流进行，Alice 先开始 。 每回合，玩家从行的 开始 或 结束 处取走整堆石头。
这种情况一直持续到没有更多的石子堆为止，此时手中 石子最多 的玩家 获胜 。
假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。

示例 1：
输入：piles = [5,3,4,5]
输出：true
解释：
Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。
示例 2：
输入：piles = [3,7,2,3]
输出：true

提示：
2 <= piles.length <= 500
piles.length 是 偶数
1 <= piles[i] <= 500
sum(piles[i]) 是 奇数
*/

/*
piles.length 是 偶数
石子的 总数 是 奇数 ，所以没有平局
Alice 先开始
当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false
假设 Alice 和 Bob 都发挥出最佳水平,意思都会主动选大的

比如 piles=[2, 1, 9, 5]，你先拿，可以拿 2 或者 5，你选择 2。
piles=[1, 9, 5]，轮到对手，可以拿 1 或 5，他选择 5。
piles=[1, 9] 轮到你拿，你拿 9。
最后，你的对手只能拿 1 了。
这样下来，你总共拥有 2 + 9 = 11 颗石头，对手有 5 + 1 = 6 颗石头，你是可以赢的，所以算法应该返回 true。

你看到了，并不是简单的挑数字大的选，为什么第一次选择 2 而不是 5 呢？因为 5 后面是 9，
你要是贪图一时的利益，就把 9 这堆石头暴露给对手了，那你就要输了。
这也是强调双方都很聪明的原因，算法也是求最优决策过程下你是否能赢。
这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。
但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。
boolean stoneGame(int[] piles) {
    return true;
}
沃日。。
*/

/*
因为石子堆数是偶数堆，比如 1234 你可以选择 1或者4
如果你选择奇数1剩余234 对手只能拿偶数2 或者4，然后你一直奇数，不要换，对手一直只能偶数
如果你选择偶数4，剩余123 对手只能拿奇数 1或者3，然后你一直偶数不换，对手一直只能奇数
所以你只要在那之前知道奇数的和大还是偶数的和大就行
如果奇数大，你就拿1左边开始，如果偶数大，你就拿4后边开始
*/
func stoneGame(piles []int) bool {
	return true
}
