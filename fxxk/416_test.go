package fxxk

import (
	"fmt"
	"testing"
)

/*
416. 分割等和子集
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
示例 2：
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。

提示：
1 <= nums.length <= 200
1 <= nums[i] <= 100
*/

/*
分成两个元素和相等的子集，看了下例子难道是直接求和然后除以2，然后当target来处理？
先按照这个思路来一遍
*/

/*var dp416 []int
func canPartition(nums []int) bool {
	if len(nums) == 1 {
		return false
	}
	sum := 0
	for _, num := range nums {
		sum += num
	}
	if sum%2 == 1 {
		//取余不等于0说明为奇数，那就不能切割成2个和相等的子集
		return false
	}
	target := sum / 2
	dp416 = make([]int, 0)
	//下面什么递归回溯全都可以用上了，因为有更优解所以直接上带备忘录的dp
	//这题翻译一下就是在nums中找到一个子集，使得其和为target
	//dp[i][target] 表示数组 使用数组nums[i]可以组成的所有target 值
	//因为也没有让给出具体怎么个子集，判断可以不可以就行，所以可以整成一个一维数组，把之前的值都追加到当前的一维数组中来
	//换成一维数组的话，那dp[i]的含义就是遍历到nums[i]时，存在的target所有可能性
	for i := 0; i < len(nums); i++ {
		tmp := make([]int, len(dp416))
		copy(tmp, dp416)
		for j := 0; j < len(tmp); j++ {
			if tmp[j]+nums[i] < target {
				dp416 = append(dp416, tmp[j]+nums[i])
			} else if tmp[j]+nums[i] == target {
				return true
			}
		}
		if nums[i] < target {
			dp416 = append(dp416, nums[i])
		} else if nums[i] == target {
			return true
		}
	}
	return false
	//	这个代码执行发现内存超过限制了。优化一下
}*/

// 一维数组，需要优化，可以先继续二维数组吧
/*var dp416 [][]int

func canPartition1(nums []int) bool {
	if len(nums) == 1 {
		return false
	}
	sum := 0
	for _, num := range nums {
		sum += num
	}
	if sum%2 == 1 {
		//取余不等于0说明为奇数，那就不能切割成2个和相等的子集
		return false
	}
	target := sum / 2
	//dp[i][target]数组 表示 使用数组nums[i]这个数 可以组成的所有值和的值
	dp416 = make([][]int, len(nums))
	for x := 0; x < len(nums); x++ {
		dp416[x] = make([]int, target+1)
	}
	//不选第一个数
	dp416[0][0] = 1
	//选第一个数

	if nums[0] == target {
		return true
	} else if nums[0] < target {
		dp416[0][nums[0]] = 1
	}

	for i := 1; i < len(nums); i++ {
		current := nums[i]
		for j := 0; j < target+1; j++ {
			if dp416[i-1][j] == 1 {
				//	表示前面数合成了这个target，算一下加上本数可以合成哪些
				if j+current < target {
					//加上本数还不足target 那可以考虑加上本数或者不加上本数两种情况
					dp416[i][j+current] = 1
					dp416[i][j] = 1
				} else if j+current == target {
					return true
				} else if j+current > target {
					//加上本数大于target 那只能考虑不加上本数一种情况
					dp416[i][j] = 1
				}
			}
		}
	}
	return false
}
*/
//写完在写一维数组的dp
//刚刚发现其实dp[i]xx 只和dp[i-1]xx有关
//整一个一维数组 dp416[i] 为 nums 这个元素是，所有元素和的可能性 然后找i=target的数是否为1
var dp416 []int

func canPartition2(nums []int) bool {
	if len(nums) == 1 {
		return false
	}
	sum := 0
	for _, num := range nums {
		sum += num
	}
	if sum%2 == 1 {
		//取余不等于0说明为奇数，那就不能切割成2个和相等的子集
		return false
	}
	target := sum / 2
	dp416 = make([]int, target+1)

	dp416[0] = 1
	if nums[0] == target {
		return true
	} else if nums[0] < target {
		dp416[nums[0]] = 1
	}

	for i := 1; i < len(nums); i++ {
		current := nums[i]
		for j := 0; j < target+1; j++ {
			//dp416[j] 遍历到nums前一个元素时，对应元素和 结果=j的情况
			if dp416[j] == 1 {
				if j+current == target {
					return true
				} else if j+current < target {
					//	加上本元素还小于target，那就算上或者不算上本元素和两种情况
					//dp416[j] = 1
					dp416[j+current] = 1
				}
			}
		}
	}
	return false
}

/*
写完发现一维数组还是不够，但是二维数组的维度可以缩小，其实只需要两个一维数组交替存值就可以了
*/
var dp416_3 [][]int

func canPartition3(nums []int) bool {
	if len(nums) == 1 {
		return false
	}
	sum := 0
	for _, num := range nums {
		sum += num
	}
	if sum%2 == 1 {
		return false
	}
	target := sum / 2
	dp416_3 = make([][]int, 2)
	dp416_3[0] = make([]int, target+1)
	dp416_3[1] = make([]int, target+1)

	dp416_3[0][0] = 1
	if nums[0] == target {
		return true
	} else if nums[0] < target {
		dp416_3[0][nums[0]] = 1
	}

	for i := 1; i < len(nums); i++ {
		current := nums[i]
		for j := 0; j < target+1; j++ {
			//dp416[j] 遍历到nums前一个元素时，对应元素和 结果=j的情况
			if dp416_3[(i+1)%2][j] == 1 {
				if j+current == target {
					return true
				} else if j+current < target {
					//	加上本元素还小于target，那就算上或者不算上本元素和两种情况
					dp416_3[i%2][j] = 1
					dp416_3[i%2][j+current] = 1
				} else if j+current > target {
					dp416_3[i%2][j] = 1
				}
				dp416_3[(i+1)%2][j] = 0
			}
		}
	}
	return false
}

//递归写一下
//sort.Ints(nums)

func TestAl416(t *testing.T) {
	//fmt.Println(canPartition2([]int{9, 5}))
	//fmt.Println(canPartition2([]int{1, 2, 3, 4, 5, 3}))
	//fmt.Println(canPartition1([]int{1, 2, 3, 4, 5, 3}))
	//fmt.Println(canPartition1([]int{14, 9, 8, 4, 3, 2}))
	fmt.Println(canPartition3([]int{14, 9, 8, 4, 3, 2}))
	//fmt.Println(canPartition2([]int{100, 100, 99, 97}))
	//fmt.Println(canPartition3([]int{10, 10, 9, 7}))
	//fmt.Println(canPartition2([]int{100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 97}))
	//fmt.Println(canPartition1([]int{100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 97}))
	//[100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,97]
}
