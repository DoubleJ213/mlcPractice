package fxxk

import (
	"fmt"
	"testing"
)

/*
172. 阶乘后的零
给定一个整数 n ，返回 n! 结果中尾随零的数量。
提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1

示例 1：
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
示例 2：
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
示例 3：
输入：n = 0
输出：0

提示：
0 <= n <= 10^4
进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？
*/

var sum172 int

// n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
func trailingZeroes1(n int) int {
	if n == 0 {
		return 0
	}
	sum172 = 1
	subTrail(n)
	//开始算几个0
	res172 := 0
	for sum172%10 == 0 {
		//sum172 = sum172 & (sum172 - 1) // 这个是二进制表示后去除末尾非0
		//取余
		res172++
		sum172 = sum172 / 10
	}
	return res172
}

func subTrail(num int) {
	if num == 0 {
		return
	}
	sum172 *= num
	subTrail(num - 1)
}

/*
上面超时了，而且比如求100阶乘，直接溢出了

首先末尾有多少个 0 ，只需要给当前数乘以一个 10 就可以加一个 0。
再具体对于 5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，
原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。
我们把每个乘数再稍微分解下，看一个例子。
11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 =
11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1
对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 ...
对于含有 5 的因子的话是 1 * 5, 2 * 5...
含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，
所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。
直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。
怎么找因子为5的数字 整除5能除清吗？不完全对。找两个例子看一下
5 10 15 20
24 = 620448401733239439360000    4个0
25 = 15511210043330985984000000  6个0
原因25*2*2=100
25这个数，一下就2个0。25有2个因子5
*/
func trailingZeroes(n int) int {
	//if n == 0 {
	//	return 0
	//}
	res172 := 0
	for i := n; i > 0; i-- {
		x := i
		for x%5 == 0 {
			res172++
			x = x / 5
		}
	}
	return res172
}

func TestAl172(t *testing.T) {
	fmt.Println(trailingZeroes(624))
	fmt.Println(trailingZeroes(625))
	fmt.Println(trailingZeroes(0))
}
